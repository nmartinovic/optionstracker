Directory structure:
└── optionstracker/
    ├── README.md
    ├── requirements.txt
    ├── config/
    │   └── options.json
    ├── docs/
    │   ├── app.js
    │   ├── index.html
    │   ├── style.css
    │   ├── .nojekyll
    │   └── data/
    │       ├── history.csv
    │       ├── last_run.txt
    │       └── portfolio.csv
    ├── scripts/
    │   └── fetch_and_update.py
    └── .github/
        └── workflows/
            └── daily.yaml

================================================
FILE: README.md
================================================

# Options Tracker (GitHub Pages + GitHub Actions)

A simple static site that tracks the *marked* value of your options portfolio daily and charts progress over time.
- Hosted on GitHub Pages (`/docs` folder).
- Automatically updates daily via GitHub Actions.
- Price = midpoint between bid/ask minus $0.05, floored at $0.00.


## Quick Start

1. **Create a new GitHub repo** and upload this folder's contents.
2. Edit `config/options.json` with your options positions (examples included).
3. Commit + push to `main` (or your default branch).
4. **Enable GitHub Pages** in repo settings:
   - Source: `Deploy from a branch`
   - Branch: `main`
   - Folder: `/docs`
5. The site will be available at: `https://<your-username>.github.io/<repo-name>/`
6. The scheduled workflow runs daily and writes data to `docs/data/`. You can also run it manually in the Actions tab.

> Note: This uses free, public Yahoo Finance data via `yfinance`. If you prefer a commercial API (Polygon, Finnhub, Tradier, etc.), swap out the fetch logic in `scripts/fetch_and_update.py`.

## Configure Your Positions

Edit `config/options.json`:
```json
{
  "base_currency": "USD",
  "positions": [
    {
      "underlying": "AAPL",
      "expiry": "2025-09-19",
      "type": "call",
      "strike": 200,
      "contracts": 2,
      "cost_per_contract": 5.50
    },
    {
      "underlying": "MSFT",
      "expiry": "2025-12-19",
      "type": "put",
      "strike": 300,
      "contracts": 1,
      "cost_per_contract": 12.40
    }
  ]
}
```
- `type`: `"call"` or `"put"`
- `contracts`: number of contracts (1 contract = 100 shares)
- `cost_per_contract`: entry price in USD **per contract** (not per 100 shares)

## What gets recorded?

Daily marks (UTC date):
- Per-option price = `max(((bid + ask)/2 - 0.05), 0.00)`
- Value = `price * contracts * 100`
- P&L = `value - (cost_per_contract * contracts * 100)`
- Portfolio totals are also computed and stored.

Data files saved to `docs/data/`:
- `history.csv`: per-position snapshot for each run
- `portfolio.csv`: aggregated portfolio value and P&L by date
- `last_run.txt`: timestamp of the last successful update

## Local Testing

You can run the script locally:
```bash
pip install -r requirements.txt
python scripts/fetch_and_update.py
```
Then open `docs/index.html` in your browser.

## Notes & Limitations
- Yahoo Finance data may occasionally omit a bid/ask for certain contracts. In that case, we fallback to `lastPrice - 0.05` (floored at $0).
- Schedule uses UTC. Default is once daily at `23:10 UTC`. Adjust in `.github/workflows/daily.yaml` if you prefer.
- This is for **personal use**; no guarantees for accuracy or completeness.



================================================
FILE: requirements.txt
================================================
yfinance==0.2.52
pandas==2.2.2
pytz==2024.1
requests==2.32.3



================================================
FILE: config/options.json
================================================
{
  "base_currency": "USD",
  "positions": [
    {
      "underlying": "CB",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 300,
      "contracts": 1,
      "cost_per_contract": 42.7
    },
    {
      "underlying": "COF",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 160,
      "contracts": 1,
      "cost_per_contract": 35.5
    },
    {
      "underlying": "DPZ",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 580,
      "contracts": 1,
      "cost_per_contract": 37.6
    },
    {
      "underlying": "HD",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 420,
      "contracts": 1,
      "cost_per_contract": 25.95
    },
    {
      "underlying": "JNJ",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 155,
      "contracts": 1,
      "cost_per_contract": 22.7
    },
    {
      "underlying": "MCD",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 340,
      "contracts": 1,
      "cost_per_contract": 24.7
    },
    {
      "underlying": "MWA",
      "expiry": "2026-02-20",
      "type": "call",
      "strike": 22.5,
      "contracts": 5,
      "cost_per_contract": 3.91
    },
    {
      "underlying": "NGD",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 3,
      "contracts": 10,
      "cost_per_contract": 1.15
    },
    {
      "underlying": "ORCL",
      "expiry": "2027-01-15",
      "type": "call",
      "strike": 130,
      "contracts": 1,
      "cost_per_contract": 44.2
    },
    {
      "underlying": "RSVR",
      "expiry": "2026-01-16",
      "type": "call",
      "strike": 5,
      "contracts": 11,
      "cost_per_contract": 2.72
    },
    {
      "underlying": "TSLA",
      "expiry": "2027-06-17",
      "type": "call",
      "strike": 800,
      "contracts": 1,
      "cost_per_contract": 22.95
    }
  ]
}


================================================
FILE: docs/app.js
================================================
let portfolioChart = null;
let portfolioRows = []; // from portfolio.csv
let historyRows = [];   // from history.csv
let currentFilter = null; // underlying or null

async function fetchText(path) {
  const res = await fetch(path, { cache: "no-cache" });
  if (!res.ok) return "";
  return res.text();
}

function parseCSV(text) {
  const lines = text.trim().split(/\r?\n/);
  if (lines.length <= 1) return { headers: [], rows: [] };
  const headers = lines[0].split(",");
  const rows = lines.slice(1).map(line => {
    const cols = line.split(",");
    const obj = {};
    headers.forEach((h, i) => obj[h] = cols[i]);
    return obj;
  });
  return { headers, rows };
}

function fmtUsd(n) {
  const num = typeof n === "string" ? parseFloat(n) : n;
  if (Number.isNaN(num)) return "-";
  return num.toLocaleString(undefined, { style: "currency", currency: "USD", maximumFractionDigits: 2 });
}

function byDateAsc(a, b) { return a.date.localeCompare(b.date); }

async function loadLastRun() {
  const t = await fetchText("./data/last_run.txt");
  const el = document.getElementById("last-run");
  if (t) el.textContent = "Last update: " + new Date(t.trim()).toLocaleString();
  else el.textContent = "Last update: (not yet recorded)";
}

/* ---------- HEADER STATS (overall vs filtered) ---------- */

function setHeaderStats(totalValue, totalPnl, totalPct) {
  const vEl = document.getElementById("stat-total-value");
  const pEl = document.getElementById("stat-total-pnl");
  const pctEl = document.getElementById("stat-total-pct");

  if (vEl) vEl.textContent = fmtUsd(totalValue ?? 0);
  if (pEl) {
    pEl.textContent = fmtUsd(totalPnl ?? 0);
    pEl.classList.toggle("good", (totalPnl ?? 0) >= 0);
    pEl.classList.toggle("bad", (totalPnl ?? 0) < 0);
  }
  if (pctEl) {
    const txt = isFinite(totalPct) ? totalPct.toFixed(2) + "%" : "-";
    pctEl.textContent = txt;
    pctEl.classList.toggle("good", (totalPct ?? 0) >= 0);
    pctEl.classList.toggle("bad", (totalPct ?? 0) < 0);
  }
}

function updateHeaderStatsOverall() {
  if (!portfolioRows.length) return;
  const rows = [...portfolioRows].sort(byDateAsc);
  const latest = rows[rows.length - 1];
  const totalValue = parseFloat(latest.total_value);
  const totalCost  = parseFloat(latest.total_cost_basis);
  const totalPnl   = parseFloat(latest.total_pnl);
  const totalPct   = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
  setHeaderStats(totalValue, totalPnl, totalPct);
}

function updateHeaderStatsUnderlying(underlying) {
  if (!historyRows.length) return;
  // find latest date present in history
  const dates = Array.from(new Set(historyRows.map(r => r.date))).sort();
  if (!dates.length) return;
  const latestDate = dates[dates.length - 1];

  // sum value and cost for that underlying on the latest date
  const todays = historyRows.filter(r => r.date === latestDate && r.underlying === underlying);
  let totalValue = 0, totalCost = 0;
  for (const r of todays) {
    const value = parseFloat(r.value);
    const cpc   = parseFloat(r.cost_per_contract);
    const cons  = parseInt(r.contracts, 10);
    const cost  = (isFinite(cpc) && isFinite(cons)) ? cpc * cons * 100 : 0;
    totalValue += isFinite(value) ? value : 0;
    totalCost  += isFinite(cost) ? cost : 0;
  }
  const totalPnl = totalValue - totalCost;
  const totalPct = totalCost > 0 ? (totalPnl / totalCost) * 100 : 0;
  setHeaderStats(totalValue, totalPnl, totalPct);
}

function updateHeaderStatsByFilter() {
  if (currentFilter) updateHeaderStatsUnderlying(currentFilter);
  else updateHeaderStatsOverall();
}

/* ---------- LOADERS ---------- */

async function loadStats() {
  const text = await fetchText("./data/portfolio.csv");
  const { rows } = parseCSV(text);
  portfolioRows = rows;
  // show overall by default; filtered view will override
  updateHeaderStatsOverall();
}

async function loadHistory() {
  const text = await fetchText("./data/history.csv");
  const { rows } = parseCSV(text);
  historyRows = rows;
}

function computeSeriesAll() {
  if (!portfolioRows.length) return { labels: [], value: [], pnl: [], pct: [] };
  const rows = [...portfolioRows].sort(byDateAsc);
  const labels = rows.map(r => r.date);
  const value  = rows.map(r => parseFloat(r.total_value));
  const pnl    = rows.map(r => parseFloat(r.total_pnl));
  const pct    = rows.map(r => {
    const c = parseFloat(r.total_cost_basis);
    const p = parseFloat(r.total_pnl);
    return c > 0 ? (p / c) * 100 : 0;
  });
  return { labels, value, pnl, pct };
}

function computeSeriesUnderlying(underlying) {
  if (!historyRows.length) return { labels: [], value: [], pnl: [], pct: [] };
  // aggregate per date for a given underlying
  const map = new Map(); // date -> {value, cost}
  for (const r of historyRows) {
    if (r.underlying !== underlying) continue;
    const d = r.date;
    const val = parseFloat(r.value);
    const cpc = parseFloat(r.cost_per_contract);
    const cons = parseInt(r.contracts, 10);
    const cost = (isFinite(cpc) && isFinite(cons)) ? cpc * cons * 100 : 0;
    const entry = map.get(d) || { value: 0, cost: 0 };
    entry.value += isFinite(val) ? val : 0;
    entry.cost  += isFinite(cost) ? cost : 0;
    map.set(d, entry);
  }
  const labels = Array.from(map.keys()).sort();
  const value  = labels.map(d => map.get(d).value);
  const cost   = labels.map(d => map.get(d).cost);
  const pnl    = labels.map((_, i) => value[i] - cost[i]);
  const pct    = labels.map((_, i) => cost[i] > 0 ? (pnl[i] / cost[i]) * 100 : 0);
  return { labels, value, pnl, pct };
}

/* ---------- CHART ---------- */

function percentAxisBounds(pcts) {
  const finite = pcts.filter(v => Number.isFinite(v));
  if (!finite.length) return { suggestedMin: -10, suggestedMax: 10 }; // safe default
  const minPct = Math.min(...finite);
  const maxPct = Math.max(...finite);
  // ensure 0% is included in the range (not necessarily the min)
  return {
    suggestedMin: Math.min(0, minPct),
    suggestedMax: Math.max(0, maxPct)
  };
}

function renderOrUpdateChart(series, labelPrefix = "Total") {
  const ctx = document.getElementById("portfolioChart").getContext("2d");
  const yPctBounds = percentAxisBounds(series.pct);

  const data = {
    labels: series.labels,
    datasets: [
      { label: `${labelPrefix} Value`, data: series.value, yAxisID: "y" },
      { label: `${labelPrefix} P&L`,   data: series.pnl,   yAxisID: "y" },
      { label: `${labelPrefix} Return (%)`, data: series.pct, yAxisID: "yPct", borderDash: [6, 4], pointRadius: 2 }
    ]
  };

  const opts = {
    responsive: true,
    maintainAspectRatio: false,
    interaction: { mode: "index", intersect: false },
    elements: { line: { tension: 0.25 } },
    scales: {
      y: {
        title: { display: true, text: "USD" },
        beginAtZero: false
      },
      yPct: {
        position: "right",
        title: { display: true, text: "% Return" },
        grid: { drawOnChartArea: false },
        suggestedMin: yPctBounds.suggestedMin,
        suggestedMax: yPctBounds.suggestedMax,
        ticks: { callback: v => `${v}%` }
      }
    },
    plugins: {
      tooltip: {
        callbacks: {
          label: (ctx) => {
            const ds = ctx.dataset.label || "";
            const v = ctx.parsed.y;
            if (ctx.dataset.yAxisID === "yPct") return `${ds}: ${v.toFixed(2)}%`;
            return `${ds}: ${fmtUsd(v)}`;
          }
        }
      }
    }
  };

  if (portfolioChart) {
    portfolioChart.data = data;
    portfolioChart.options = opts;
    portfolioChart.update();
  } else {
    portfolioChart = new Chart(ctx, { type: "line", data, options: opts });
  }
}

/* ---------- FILTERING ---------- */

function applyFilter(underlying) {
  currentFilter = underlying;
  const series = computeSeriesUnderlying(underlying);
  renderOrUpdateChart(series, underlying);
  updateHeaderStatsByFilter();
  const badge = document.getElementById("chart-filter-label");
  if (badge) badge.textContent = `${underlying} — double-click to reset`;
}

function resetFilter() {
  currentFilter = null;
  const series = computeSeriesAll();
  renderOrUpdateChart(series, "Total");
  updateHeaderStatsByFilter();
  const badge = document.getElementById("chart-filter-label");
  if (badge) badge.textContent = "";
}

/* ---------- PAGE SECTIONS ---------- */

async function loadPortfolioChart() {
  // default view: total portfolio
  const series = computeSeriesAll();
  renderOrUpdateChart(series, "Total");
}

async function loadPositionsTable() {
  const text = await fetchText("./data/history.csv");
  const { rows } = parseCSV(text);
  historyRows = rows;
  if (!rows.length) return;

  rows.sort(byDateAsc);
  const latestDate = rows[rows.length - 1].date;
  const todays = rows.filter(r => r.date === latestDate);

  const tbody = document.querySelector("#positions-table tbody");
  tbody.innerHTML = "";

  todays.forEach(r => {
    const tr = document.createElement("tr");
    const pnl = parseFloat(r.pnl);
    const pnlPct = parseFloat(r.pnl_pct);
    tr.innerHTML = `
      <td>${r.symbolKey}</td>
      <td>${r.contracts}</td>
      <td>${fmtUsd(r.cost_per_contract)}</td>
      <td>${fmtUsd(r.price)}</td>
      <td>${fmtUsd(r.value)}</td>
      <td class="${pnl >= 0 ? "good" : "bad"}">${fmtUsd(pnl)}</td>
      <td class="${pnlPct >= 0 ? "good" : "bad"}">${(isFinite(pnlPct) ? pnlPct.toFixed(2) : "-")}%</td>
    `;
    // click-to-filter by underlying (first token of symbolKey)
    tr.addEventListener("click", () => {
      const firstCell = tr.querySelector("td");
      const key = (firstCell?.textContent || "").trim();
      const underlying = key.split(" ")[0];
      if (underlying) applyFilter(underlying);
    });
    tbody.appendChild(tr);
  });

  // double-click to reset filter (chart and table)
  const table = document.getElementById("positions-table");
  table.addEventListener("dblclick", resetFilter);

  const canvas = document.getElementById("portfolioChart");
  canvas.addEventListener("dblclick", resetFilter);
}

/* ---------- INIT ---------- */

async function init() {
  await Promise.all([
    loadLastRun(),
    loadStats(),   // sets overall stats + stores portfolioRows
    loadHistory()  // stores historyRows for filtering
  ]);
  await loadPortfolioChart();
  await loadPositionsTable();
}
init();



================================================
FILE: docs/index.html
================================================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Options Tracker</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" />
    <link rel="preconnect" href="https://unpkg.com" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="./style.css" />
  </head>
  <body>
    <header class="container">
      <h1>📈 Options Tracker</h1>
      <p class="muted">Midpoint − $0.05 per contract, floored at $0.00. Updated daily.</p>
      <p id="last-run" class="muted">Last update: …</p>

      <!-- Top-level stats -->
      <section class="stats card">
        <div class="stat">
          <div class="label">Total Value</div>
          <div id="stat-total-value" class="value">—</div>
        </div>
        <div class="stat">
          <div class="label">Total Return ($)</div>
          <div id="stat-total-pnl" class="value">—</div>
        </div>
        <div class="stat">
          <div class="label">Total Return (%)</div>
          <div id="stat-total-pct" class="value">—</div>
        </div>
      </section>
    </header>

    <main class="container">
      <section class="card">
        <h2>
          Portfolio Value &amp; P&amp;L Over Time
          <span id="chart-filter-label" class="badge"></span>
        </h2>
        <canvas id="portfolioChart"></canvas>
      </section>

      <section class="card">
        <h2>Today’s Positions</h2>
        <div class="table-wrap">
          <table id="positions-table">
            <thead>
              <tr>
                <th>Symbol</th>
                <th>Contracts</th>
                <th>Cost/Contract</th>
                <th>Marked Price</th>
                <th>Value</th>
                <th>P&amp;L</th>
                <th>P&amp;L %</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </section>
    </main>

    <footer class="container muted small">
      <p>Data via Cboe delayed options feed (server-side). For personal use only.</p>
    </footer>

    <script src="./app.js"></script>
  </body>
</html>



================================================
FILE: docs/style.css
================================================
:root {
  --bg: #0b0d10;
  --card: #12161b;
  --text: #e5e7eb;
  --muted: #94a3b8;
  --accent: #60a5fa;
  --good: #16a34a;
  --bad: #ef4444;
  --border: #1f2937;
}

* { box-sizing: border-box; }
html, body { margin: 0; padding: 0; background: var(--bg); color: var(--text); font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
.container { width: 100%; max-width: 1100px; margin: 0 auto; padding: 16px; }
header h1 { margin: 0 0 8px; font-weight: 700; letter-spacing: 0.3px; }
.muted { color: var(--muted); }
.small { font-size: 0.9rem; }

.card {
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 16px;
  margin: 16px 0;
  box-shadow: 0 2px 12px rgba(0,0,0,0.2);
}

/* --- stats layout --- */
.stats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
}
.stat .label { color: var(--muted); font-size: 0.9rem; margin-bottom: 6px; }
.stat .value { font-size: 1.6rem; font-weight: 700; }

/* Table */
.table-wrap { overflow: auto; border-radius: 12px; border: 1px solid var(--border); -webkit-overflow-scrolling: touch; }
table { width: 100%; border-collapse: collapse; font-size: 0.95rem; }
thead { background: #111827; }
th, td { padding: 10px 12px; border-bottom: 1px solid var(--border); text-align: right; white-space: nowrap; }
th:first-child, td:first-child { text-align: left; white-space: normal; }
tbody tr:hover { background: rgba(255,255,255,0.03); }
tbody tr { cursor: pointer; }

/* Chart sizing */
#portfolioChart { display: block; width: 100%; max-height: 380px; }

/* Colors */
.bad { color: var(--bad); }
.good { color: var(--good); }

/* small badge next to title */
.badge { margin-left: 8px; color: var(--muted); font-size: 0.9rem; font-weight: 600; }

/* --- mobile tweaks --- */
@media (max-width: 640px) {
  .container { padding: 12px; }
  header h1 { font-size: 1.35rem; }
  .card { padding: 12px; margin: 12px 0; }

  .stats { grid-template-columns: 1fr; gap: 10px; }
  .stat .value { font-size: 1.4rem; }

  table { font-size: 0.9rem; }
  th, td { padding: 8px 10px; }

  #portfolioChart { max-height: 280px; }
}



================================================
FILE: docs/.nojekyll
================================================
Tue Aug 26 18:24:20 UTC 2025



================================================
FILE: docs/data/history.csv
================================================
date,symbolKey,underlying,expiry,type,strike,contracts,cost_per_contract,price,value,pnl,pnl_pct
2025-08-26,CB 2027-01-15 C 300,CB,2027-01-15,call,300.00,1,42.70,15.70,1570.00,-2700.00,-63.23
2025-08-26,COF 2027-01-15 C 160,COF,2027-01-15,call,160.00,1,35.50,78.85,7885.00,4335.00,122.11
2025-08-26,DPZ 2027-01-15 C 580,DPZ,2027-01-15,call,580.00,1,37.60,19.95,1995.00,-1765.00,-46.94
2025-08-26,HD 2027-01-15 C 420,HD,2027-01-15,call,420.00,1,25.95,38.95,3895.00,1300.00,50.10
2025-08-26,JNJ 2027-01-15 C 155,JNJ,2027-01-15,call,155.00,1,22.70,30.12,3012.00,742.00,32.69
2025-08-26,MCD 2027-01-15 C 340,MCD,2027-01-15,call,340.00,1,24.70,18.97,1897.00,-573.00,-23.20
2025-08-26,MWA 2026-02-20 C 22.5,MWA,2026-02-20,call,22.50,5,3.91,6.60,3300.00,1345.00,68.80
2025-08-26,NGD 2027-01-15 C 3,NGD,2027-01-15,call,3.00,10,1.15,2.95,2950.00,1800.00,156.52
2025-08-26,ORCL 2027-01-15 C 130,ORCL,2027-01-15,call,130.00,1,44.20,114.58,11458.00,7038.00,159.23
2025-08-26,RSVR 2026-01-16 C 5,RSVR,2026-01-16,call,5.00,11,2.72,3.90,4290.00,1298.00,43.38
2025-08-26,TSLA 2027-06-17 C 800,TSLA,2027-06-17,call,800.00,1,22.95,36.62,3662.00,1367.00,59.56
2025-08-27,CB 2027-01-15 C 300,CB,2027-01-15,call,300.00,1,42.70,16.70,1670.00,-2600.00,-60.89
2025-08-27,COF 2027-01-15 C 160,COF,2027-01-15,call,160.00,1,35.50,78.70,7870.00,4320.00,121.69
2025-08-27,DPZ 2027-01-15 C 580,DPZ,2027-01-15,call,580.00,1,37.60,20.45,2045.00,-1715.00,-45.61
2025-08-27,HD 2027-01-15 C 420,HD,2027-01-15,call,420.00,1,25.95,39.85,3985.00,1390.00,53.56
2025-08-27,JNJ 2027-01-15 C 155,JNJ,2027-01-15,call,155.00,1,22.70,30.00,3000.00,730.00,32.16
2025-08-27,MCD 2027-01-15 C 340,MCD,2027-01-15,call,340.00,1,24.70,18.32,1832.00,-638.00,-25.83
2025-08-27,MWA 2026-02-20 C 22.5,MWA,2026-02-20,call,22.50,5,3.91,6.60,3300.00,1345.00,68.80
2025-08-27,NGD 2027-01-15 C 3,NGD,2027-01-15,call,3.00,10,1.15,2.95,2950.00,1800.00,156.52
2025-08-27,ORCL 2027-01-15 C 130,ORCL,2027-01-15,call,130.00,1,44.20,115.58,11558.00,7138.00,161.49
2025-08-27,RSVR 2026-01-16 C 5,RSVR,2026-01-16,call,5.00,11,2.72,3.90,4290.00,1298.00,43.38
2025-08-27,TSLA 2027-06-17 C 800,TSLA,2027-06-17,call,800.00,1,22.95,35.48,3548.00,1253.00,54.60



================================================
FILE: docs/data/last_run.txt
================================================
2025-08-27T23:26:05.990817+00:00


================================================
FILE: docs/data/portfolio.csv
================================================
date,total_value,total_cost_basis,total_pnl
2025-08-26,45914.00,31727.00,14187.00
2025-08-27,46048.00,31727.00,14321.00



================================================
FILE: scripts/fetch_and_update.py
================================================
import os, json, math, time, random, re
from datetime import datetime, timezone, date
import requests

ROOT = os.path.dirname(os.path.dirname(__file__))
DOCS_DATA = os.path.join(ROOT, "docs", "data")
CONFIG_PATH = os.path.join(ROOT, "config", "options.json")
os.makedirs(DOCS_DATA, exist_ok=True)

HISTORY_CSV   = os.path.join(DOCS_DATA, "history.csv")
PORTFOLIO_CSV = os.path.join(DOCS_DATA, "portfolio.csv")
LAST_RUN      = os.path.join(DOCS_DATA, "last_run.txt")

FAST_MODE = os.getenv("FAST_MODE") == "1" or os.getenv("GITHUB_EVENT_NAME") == "workflow_dispatch"
MAX_RETRIES        = 2 if FAST_MODE else 4
BASE_SLEEP         = 0.6 if FAST_MODE else 1.0
JITTER             = 0.3
BETWEEN_UNDERLYINGS= 0.15 if FAST_MODE else 0.5
INITIAL_STAGGER_MAX= 0.0 if FAST_MODE else 2.5

CBOE_URL = "https://cdn.cboe.com/api/global/delayed_quotes/options/{sym}.json"
UA = {"User-Agent": "options-tracker/1.0", "Accept": "application/json"}

def read_config(path: str):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def symbol_key(pos):
    t = "C" if pos["type"].lower().startswith("c") else "P"
    return f'{pos["underlying"]} {pos["expiry"]} {t} {pos["strike"]}'

def is_nan(x):
    try: return math.isnan(float(x))
    except Exception: return False

def mark_price(bid, ask, last_price):
    if bid is not None and ask is not None and not (is_nan(bid) or is_nan(ask)):
        px = (float(bid) + float(ask)) / 2.0 - 0.05
    else:
        if last_price is None or is_nan(last_price): return 0.0
        px = float(last_price) - 0.05
    return round(max(px, 0.0), 2)

def backoff_sleep(attempt: int):
    delay = (BASE_SLEEP * (2 ** attempt)) + random.uniform(-JITTER, JITTER)
    time.sleep(max(0.15, delay))

def fetch_cboe_chain(sym: str):
    # For equities/ETFs just {SYM}.json; indexes use leading underscore (not needed for your list)
    url = CBOE_URL.format(sym=sym.upper())
    last_err = None
    for a in range(MAX_RETRIES):
        try:
            r = requests.get(url, headers=UA, timeout=12)
            if r.status_code in (429, 503):
                last_err = Exception(f"{r.status_code} from Cboe")
                backoff_sleep(a); continue
            r.raise_for_status()
            j = r.json()
            # Data shape is either {"options":[...]} or {"data":{"options":[...]}}
            opts = j.get("options")
            if opts is None and isinstance(j.get("data"), dict):
                opts = j["data"].get("options")
            if not opts: return []
            # normalize numeric fields and keep OPRA symbol
            out = []
            for o in opts:
                # keys vary; handle both "last" and "last_trade_price"
                last = o.get("last")
                if last is None: last = o.get("last_trade_price")
                out.append({
                    "opra":     o.get("option") or o.get("symbol") or "",
                    "bid":      _tofloat(o.get("bid")),
                    "ask":      _tofloat(o.get("ask")),
                    "last":     _tofloat(last),
                })
            return out
        except Exception as e:
            last_err = e
            backoff_sleep(a)
    print(f"[ERROR] Cboe fetch failed for {sym}: {last_err}")
    return []

def _tofloat(x):
    try:
        if x in (None, "", "NaN"): return float("nan")
        return float(x)
    except Exception:
        return float("nan")

# OPRA parser: <root><YY><MM><DD><C|P><strike*1000 8-digits>
OPRA_RE = re.compile(r"^(?P<root>[A-Z]{1,6})(?P<yy>\d{2})(?P<mm>\d{2})(?P<dd>\d{2})(?P<cp>[CP])(?P<strike>\d{8})$")

def parse_opra(opra: str):
    m = OPRA_RE.match(opra)
    if not m: return None
    yy = int(m.group("yy"))
    year = 2000 + yy  # good till 2099
    month = int(m.group("mm")); day = int(m.group("dd"))
    cp = "call" if m.group("cp") == "C" else "put"
    strike = int(m.group("strike")) / 1000.0
    try:
        exp = date(year, month, day).strftime("%Y-%m-%d")
    except Exception:
        return None
    return {"expiry": exp, "type": cp, "strike": strike}

def ensure_csv_headers():
    if not os.path.exists(HISTORY_CSV):
        with open(HISTORY_CSV, "w", encoding="utf-8") as f:
            f.write("date,symbolKey,underlying,expiry,type,strike,contracts,cost_per_contract,price,value,pnl,pnl_pct\n")
    if not os.path.exists(PORTFOLIO_CSV):
        with open(PORTFOLIO_CSV, "w", encoding="utf-8") as f:
            f.write("date,total_value,total_cost_basis,total_pnl\n")

def replace_today(file_path: str, header_line: str, date_str: str):
    if not os.path.exists(file_path):
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(header_line); return
    with open(file_path, "r", encoding="utf-8") as f:
        lines = f.read().splitlines()
    if not lines: lines = [header_line.strip()]
    head = lines[0]
    body = [ln for ln in lines[1:] if not ln.startswith(date_str + ",")]
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(head + ("\n" if not head.endswith("\n") else ""))
        for ln in body: f.write(ln + "\n")

def append_history(rows):
    with open(HISTORY_CSV, "a", encoding="utf-8") as f:
        for r in rows:
            f.write("{date},{symbolKey},{underlying},{expiry},{type},{strike},{contracts},{cost_per_contract},{price},{value},{pnl},{pnl_pct}\n".format(**r))

def append_portfolio(date_str, total_value, total_cost, total_pnl):
    with open(PORTFOLIO_CSV, "a", encoding="utf-8") as f:
        f.write(f"{date_str},{total_value:.2f},{total_cost:.2f},{total_pnl:.2f}\n")

def nearest(items, key_fn, target):
    # find item minimizing abs(key(item) - target)
    return min(items, key=lambda it: abs(key_fn(it) - target))

def nearest_expiry(requested: str, expiries: list[str]) -> str:
    if requested in expiries: return requested
    try:
        req = datetime.strptime(requested, "%Y-%m-%d").date()
        dd = [datetime.strptime(e, "%Y-%m-%d").date() for e in expiries]
        best = min(dd, key=lambda d: abs((d - req).days))
        return best.strftime("%Y-%m-%d")
    except Exception:
        return requested

def main():
    if INITIAL_STAGGER_MAX > 0:
        time.sleep(random.uniform(0, INITIAL_STAGGER_MAX))

    cfg = read_config(CONFIG_PATH)
    positions = cfg.get("positions", [])
    ensure_csv_headers()

    date_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    replace_today(HISTORY_CSV, "date,symbolKey,underlying,expiry,type,strike,contracts,cost_per_contract,price,value,pnl,pnl_pct\n", date_str)
    replace_today(PORTFOLIO_CSV, "date,total_value,total_cost_basis,total_pnl\n", date_str)

    # group by underlying
    by_ul = {}
    for p in positions:
        by_ul.setdefault(p["underlying"].upper(), []).append(p)

    total_value = 0.0
    total_cost  = 0.0
    history_rows = []

    for underlying, plist in by_ul.items():
        raw = fetch_cboe_chain(underlying)
        if not raw:
            print(f"[WARN] No chain from Cboe for {underlying}")
            for pos in plist:
                contracts = int(pos["contracts"])
                cost_basis = float(pos["cost_per_contract"]) * contracts * 100.0
                history_rows.append({
                    "date": date_str,
                    "symbolKey": symbol_key(pos),
                    "underlying": pos["underlying"],
                    "expiry": pos["expiry"],
                    "type": pos["type"].lower(),
                    "strike": f"{float(pos['strike']):.2f}",
                    "contracts": str(contracts),
                    "cost_per_contract": f"{float(pos['cost_per_contract']):.2f}",
                    "price": f"{0.00:.2f}",
                    "value": f"{0.00:.2f}",
                    "pnl": f"{(-cost_basis):.2f}",
                    "pnl_pct": f"{(-100.0):.2f}" if cost_basis > 0 else "0.00",
                })
                total_cost += cost_basis
            time.sleep(BETWEEN_UNDERLYINGS)
            continue

        # Parse OPRA, keep only well-formed rows
        parsed = []
        for r in raw:
            opra = (r.get("opra") or "").strip().upper()
            info = parse_opra(opra)
            if not info: continue
            parsed.append({
                "expiry": info["expiry"],
                "type": info["type"],  # "call"/"put"
                "strike": float(info["strike"]),
                "bid": r.get("bid"),
                "ask": r.get("ask"),
                "last": r.get("last"),
            })

        # precompute all expiries available by type
        expiries_by_type = {
            "call": sorted({x["expiry"] for x in parsed if x["type"] == "call"}),
            "put":  sorted({x["expiry"] for x in parsed if x["type"] == "put"}),
        }

        for pos in plist:
            typ = pos["type"].lower()
            strike = float(pos["strike"])
            contracts = int(pos["contracts"])
            cost_per_contract = float(pos["cost_per_contract"])
            req_exp = pos["expiry"]

            available = expiries_by_type.get(typ, [])
            use_exp = nearest_expiry(req_exp, available) if available else req_exp

            candidates = [x for x in parsed if x["type"] == typ and x["expiry"] == use_exp]
            if not candidates:
                price = 0.0
            else:
                # closest strike for that expiry
                best = nearest(candidates, key_fn=lambda x: x["strike"], target=strike)
                if abs(best["strike"] - strike) > 0.02:
                    print(f"[WARN] {underlying} {req_exp} {typ} {strike} -> {best['strike']} @ {use_exp}")
                price = mark_price(best.get("bid"), best.get("ask"), best.get("last"))

            value = price * contracts * 100.0
            cost_basis = cost_per_contract * contracts * 100.0
            pnl = value - cost_basis
            pnl_pct = (pnl / cost_basis * 100.0) if cost_basis > 0 else 0.0

            total_value += value
            total_cost  += cost_basis

            history_rows.append({
                "date": date_str,
                "symbolKey": symbol_key(pos),
                "underlying": pos["underlying"],
                "expiry": req_exp,
                "type": typ,
                "strike": f"{strike:.2f}",
                "contracts": str(contracts),
                "cost_per_contract": f"{cost_per_contract:.2f}",
                "price": f"{price:.2f}",
                "value": f"{value:.2f}",
                "pnl": f"{pnl:.2f}",
                "pnl_pct": f"{pnl_pct:.2f}",
            })

        time.sleep(BETWEEN_UNDERLYINGS)

    append_history(history_rows)
    append_portfolio(date_str, total_value, total_cost, total_value - total_cost)
    with open(LAST_RUN, "w", encoding="utf-8") as f:
        f.write(datetime.now(timezone.utc).isoformat())

if __name__ == "__main__":
    main()



================================================
FILE: .github/workflows/daily.yaml
================================================
name: Daily Options Update

concurrency:
  group: options-tracker-data
  cancel-in-progress: true

on:
  schedule:
    - cron: "10 23 * * *"   # runs daily at 23:10 UTC
  workflow_dispatch:         # enables the "Run workflow" button
  push:
    paths:
      - "config/options.json"
      - "scripts/**"

permissions:
  contents: write

jobs:
  update-data:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run fetch script
        env:
          FAST_MODE: ${{ github.event_name == 'workflow_dispatch' && '1' || '0' }}
        run: python scripts/fetch_and_update.py
      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/data/*.csv docs/data/*.txt || true
          if ! git diff --cached --quiet; then
            git commit -m "Daily data update"
            git push
          else
            echo "No changes to commit."
          fi



